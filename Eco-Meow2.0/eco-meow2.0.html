<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    
    <script type="module">
        import {OrbitControls} from './libs/OrbitControls.js'
        import * as THREE from './libs/three.module.js';
        import * as BufferGeometryUtils from './libs/BufferGeometryUtils.js';

        // const geometry = new BufferGeometry();
        let controls;

        let camera, scene, renderer, hello;
        
        window.onload = function init() {
            scene = new THREE.Scene();
            
            
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 100); // perspective camera
            camera.position.x = 2;
            camera.position.y = 2; // place the camera using world coordinates
            camera.position.z = 13;
            camera.lookAt(scene.position); //point the camera to the center of the scene
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight); // set output canvas and viewport size
            
            controls = new OrbitControls(camera, renderer.domElement);
            
            // configure renderer clear color
            renderer.setClearColor("#9BD4C3");
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // add the output of the renderer to an HTML element (adds a Canvas element to the body)
            document.body.appendChild(renderer.domElement);

            const axeHelper = new THREE.AxesHelper(5);
            scene.add(axeHelper);

        //----------------------------------------------------------------
// lights
            // let light = new THREE.AmbientLight(0xffffff, 0.7);
            let light = new THREE.AmbientLight(0xEAE178, 0.7);
            scene.add(light);

            let light2 = new THREE.PointLight(0xEAE178, 0.7);
            light2.position.set(-10, 5, 5);
            light2.castShadow = true;
            light2.shadow.camera;
            scene.add(light2);

            // light2.shadow.mapSize.width(2,2);
            // light2.shadow.mapSize.height(2,2);
            

            let light3 = new THREE.PointLight(0xEEBA77, 0.8);
            light3.position.set(5, 6, 5);
            scene.add(light3);
            // light helper
            let pointLightHelper = new THREE.PointLightHelper(light2, 0.4);
            let pointLightHelper1 = new THREE.PointLightHelper(light3, 0.4);
            // pointLightHelper.name = "helper";
            scene.add(pointLightHelper);
            scene.add(pointLightHelper1);

// ----------
// colors
const colorGreenShade = new THREE.MeshPhongMaterial({color: 0xA4C263, flatShading:true, shininess: 0});
        const colorGreen = new THREE.Color(0xA4C263);
        const colorBrown = new THREE.Color(0x8C7369);
        const colorBlack = new THREE.Color(0x494949);
        const colorWhite = new THREE.Color(0xF7F7F2);
        const colorPink = new THREE.Color(0xE8B5AC);
        const colorPurple = new THREE.Color(0xE1C5DD);
        const colorYellow = new THREE.Color(0xEAE178);

// ground

            let material = new THREE.MeshBasicMaterial({ color: 0x4b4b4b, wireframe: false });
            let geometry = new THREE.PlaneGeometry(20, 20);

            //sphere 1 (low poly)
            geometry = new THREE.BoxGeometry(2, 2, 2);
            let sphere1 = new THREE.Mesh(geometry, colorGreenShade);
            sphere1.position.set(-3, 0, 1);
            sphere1.receiveShadow = true;
            sphere1.castShadow = true;
            scene.add(sphere1);
            
function handleKeyDown(e) {
            if (e.key == "f") {
                scene.traverse(function (child) {
                    if (child instanceof THREE.Mesh && child.name == "") {
                        child.material = new THREE.MeshPhongMaterial({
                                color: 0x2194ce
                                , flatShading: true
                        });
                    }
                });
            }
        }
        document.onkeydown = handleKeyDown;

// ground
            geometry = new THREE.BoxGeometry(15, 0.5, 15)
            let plane = new THREE.Mesh(geometry, colorGreenShade);
            plane.position.y = -1;
            plane.receiveShadow = true;
            plane.name = "plane";
            scene.add(plane);


        const geometries = []
        // TRUNK: 1st geometry
// trees
        const trunk = new THREE.BoxGeometry(1, 2, 1);

            const colorsTrunk = []; // array of colors for each vertex of the trunk geometry
            for (let i = 0; i < trunk.attributes.position.count; i++)
                colorsTrunk.push(colorBrown.r, colorBrown.g, colorBrown.b);
            // add color attribute to the trunk buffer geometry
            trunk.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsTrunk), 3));

            geometries.push(trunk);

            const level1 = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            const colorsLevels = []; // array of colors for each vertex of the leaves geometry
            // Do this ONLY ONCE, since ALL 3 level geometries have the SAME number of vertices
            for (let i = 0; i < level1.attributes.position.count; i++)
                colorsLevels.push(colorGreen.r, colorGreen.g, colorGreen.b);

            level1.translate(0, 2, 0)
            // add color attribute to the level1 buffer geometry
            level1.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLevels), 3));
            geometries.push(level1);

            const level2 = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            level2.translate(1, 3, 0)
            // add color attribute to the level2 buffer geometry
            level2.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLevels), 3));
            geometries.push(level2);

            const level3 = new THREE.BoxGeometry(2, 2, 2);
            level3.translate(-0.5, 3, 1)
            // add color attribute to the level3 buffer geometry
            level3.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsLevels), 3));
            geometries.push(level3);

            const pineTreeGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries);
            const pineTree = new THREE.Mesh(
                pineTreeGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            const pineTree1 = new THREE.Mesh(
                pineTreeGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            pineTree.position.z = -5;
            pineTree.castShadow = true;
            pineTree.receiveShadow = true;
            scene.add(pineTree)
            pineTree1.castShadow = true;
            pineTree1.receiveShadow = true;
            pineTree1.position.x = -5; pineTree1.position.z = -3;
            scene.add(pineTree1)

        //------------------------

// first cat

            const catGeometries = []

            const body = new THREE.BoxGeometry(1.5, 1, 1);
            const colorsBody = []; // array of colors for each vertex of the leaves geometry
            // Do this ONLY ONCE, since ALL 3 level catGeometries have the SAME number of vertices
            for (let i = 0; i < level1.attributes.position.count; i++)
                colorsBody.push(colorBlack.r, colorBlack.g, colorBlack.b);

            body.translate(0, 0.2, 0)
            // add color attribute to the body buffer geometry
            body.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(body);

            const head = new THREE.BoxGeometry(2, 2, 1.6);
            head.translate(0, 1.7, 0)
            // add color attribute to the head buffer geometry
            head.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(head);

            const snout = new THREE.BoxGeometry(2, 1, 0.3);
            snout.translate(0, 1.2, 0.9)
            // add color attribute to the snout buffer geometry
            snout.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(snout);


            const arml = new THREE.BoxGeometry(0.4, 0.5, 0.5);
            arml.translate(-0.9, 0.4, 0)
            // add color attribute to the arml buffer geometry
            arml.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(arml);

            const armr = new THREE.BoxGeometry(0.4, 0.5, 0.5);
            armr.translate(0.9, 0.4, 0)
            // add color attribute to the armr buffer geometry
            armr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsBody), 3));
            catGeometries.push(armr);




//white parts of body

// legs
            const legl = new THREE.BoxGeometry(0.5, 0.5, 0.6);
            const colorsWhite = []; // array of colors for each vertex of the trunk geometry
            for (let i = 0; i < legl.attributes.position.count; i++)
                colorsWhite.push(colorWhite.r, colorWhite.g, colorWhite.b);

            legl.translate(-0.5, -0.55, 0)
            // add color attribute to the legl buffer geometry
            legl.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(legl);

            const legr = new THREE.BoxGeometry(0.5, 0.5, 0.6);
            legr.translate(0.5, -0.55, 0)
            // add color attribute to the legr buffer geometry
            legr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(legr);
//arms
            const forearml = new THREE.BoxGeometry(0.4, 0.5, 0.5);
            forearml.translate(-1.3, 0.4, 0)
            // add color attribute to the forearml buffer geometry
            forearml.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(forearml);

            const forearmr = new THREE.BoxGeometry(0.4, 0.5, 0.5);
            forearmr.translate(1.3, 0.4, 0)
            // add color attribute to the forearmr buffer geometry
            forearmr.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(forearmr);



            const forehead = new THREE.BoxGeometry(1, 2, 1);
            forehead.translate(0, 5,0);
            // add color attribute to the forehead buffer geometry
            forehead.setAttribute(
                'color',
                new THREE.BufferAttribute(new Float32Array(colorsWhite), 3));
            catGeometries.push(forehead);

            const blackCatGeometry = BufferGeometryUtils.mergeBufferGeometries(catGeometries);
            const blackCat = new THREE.Mesh(
                blackCatGeometry,
                new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, shininess: 0})
            )
            blackCat.castShadow = true;
            scene.add(blackCat)



// ----------------------------           
                renderer.setAnimationLoop(render);
            }
            
            function render(){
                // rotate the cube around its axes
                
                // camera.rotation.y += 0.01;
                // cube.rotation.z += 0.1;
                // rectangle.position.x = 20;
                // hello.position.y = 2
                // hello.position.z = 10;
                // hello.rotation.x += 0.1;
            renderer.render(scene, camera);
            // controls.update();


        }
    </script>
</body>
</html>